<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8">

        <title>Running Key</title>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
        <script src="js/functions.js"></script>

        <link rel="stylesheet" href="css/style.css">

    </head>
    <body>
        <div class="title-container">            
            <h1 class="title">Running Key Cryptanalysis</h1>
        </div>

        <div class="input-div">
            <h3 class="subheader">A visual aid for cryptanalyzing Vigenere autokey extended by plaintext and running key ciphyers.</h3>
            <hr>
            <br>
            <h2 class="header">Ciphertext:</h2>
            <textarea name="ciphertext" id="ciphertext" class="ciphertext-input" cols="30" rows="10"></textarea>

            <h2 class="header">Crib:</h2>
            <textarea name="crib" id="crib" class="crib-input" cols="20" rows="1"></textarea>
            <br><br>

            <button id='cryptanalyze'>Cryptanalyze</button>
            <button id='reset'>Reset</button>
            <p class="subheader">Note: This will reset any progress you have made.</p>
            <hr>
        </div>

        <div class="container" id="container"></div>

        <div class="btn-container">
            <button id='shift-left'>Shift Left</button>
            <button id='shift-right'>Shift Right</button>
        </div>

        <br>
        <p class="info">Site designed for CSC 483 by Ethan Gil</p>
        <p class="info"><a href="https://github.com/Ethan-Gil/RunningKeyTool">GitHub Repository</a></p>

        <script>
            var ciphertext;
            var plaintext;
            var key;
            var crib;
            var crib_length;
            var crib_index;
            var written_to_page = false;    // Keeps track of whether the table has been written to the page

            // Getting the ciphertext from user input
            function getCiphertextInput() {
                var ciphertext = $('#ciphertext').val();
                ciphertext = ciphertext.replace(/\s/g, ''); // Removing any spaces
                ciphertext = ciphertext.split('');          // Converting it from string to array
                ciphertext = to_uppercase(ciphertext);      // It should always be uppercase

                return ciphertext;
            }

            // Getting the crib from the user and creating the plaintext array
            // Also setting the length of the crib
            function getPlaintextInput(ciphertext) {
                crib = $('#crib').val();
                crib = crib.replace(/\s/g, '');
                crib = crib.split('');

                // Creating the plaintext array using the ciphertext and crib
                var plaintext = create_plaintext(ciphertext, crib);

                // Setting the length of the crib
                crib_length = crib.length;
                crib_index = 0;

                return plaintext;
            }

            // Creating the initial key array
            function getKeyInput(ciphertext) {
                var key = create_key(ciphertext);

                return key;
            }

            // Adding an event listener for the cryptanalyze button
            var btn = document.getElementById("cryptanalyze")
            btn.addEventListener("click", cryptanalyze);
            // DISABLE AFTER USE

            var resetBtn = document.getElementById("reset");
            resetBtn.addEventListener("click", reset);

            // Resetting all of the user input and reloading the page
            function reset() {
                document.getElementById("ciphertext").value = ""
                document.getElementById("crib").value = ""
                written_to_page = false;

                location.reload();
            }

            // Main method that writes the information to the page and awaits for further user input.
            function cryptanalyze() {

                // To prevent corruption of the user's progress, if the information has initially been written to the page, further user input isn't needed.
                if (written_to_page) return;

                // Getting the initial ciphertext, plaintext, and key based on user input.
                ciphertext = getCiphertextInput();
                plaintext = getPlaintextInput(ciphertext);
                key = getKeyInput(ciphertext);

                // Keeping track of the crib
                crib_index = 0;
                crib_length = crib.length;

                // Checking to see if the table has already been written to the page.
                // If it has, then nothing will be done.
                // Otherwise, dynamically create it and write it to the page
                if (written_to_page == false && ciphertext != "") {
                    write(ciphertext, plaintext, key);
                    written_to_page = true;
                }

                // Listening for further user input
                for (let i = 0; i < plaintext.length; i++) {

                    // Listening for plaintext changes
                    document.getElementById(`${i}`).addEventListener("keydown", (e) => {
                        
                        // Getting the key that was pressed. We will assume that this is a letter.
                        var letter = e.key;

                        // Checking for invalid keys
                        // Todo: Add in functionality to move right if the right arrow is pushed, and vice versa for the left arrow. Maybe convert it to a tab.
                        if (letter == "ArrowRight" || letter == "ArrowLeft" || letter == "ArrowUp" || letter == "ArrowDown" || letter == "Tab") {
                            console.log("Invalid Letter: " + letter);
                            return;
                        }

                        // If the user is attempting to erase a letter, we must also erase the key letter corresponding to it.
                        if (letter == "Backspace") {
                            plaintext[i] = "";
                            key[i] = "";
                            update_key(key);
                        }

                        // If the user just enters in a normal, valid letter.
                        else {
                            plaintext[i] = letter;
                            update_key(key);
                        }
                    });

                    // Listening for key changes
                    document.getElementById(`key${i}`).addEventListener("keydown", (e) => {
                        
                        var letter = e.key;

                        if (letter == "ArrowRight" || letter == "ArrowLeft" || letter == "ArrowUp" || letter == "ArrowDown" || letter == "Tab") {
                            console.log("Invalid Letter: " + letter);
                            return;
                        }

                        if (letter == "Backspace") {
                            plaintext[i] = "";
                            key[i] = "";
                            update_plaintext(plaintext);
                        }

                        else {
                        
                            // It isn't a good idea for users to be able to change the crib, as it can corrupt the work they have completed.
                            // Therefore, we will keep track of the crib's placement, and if any letter within the crib is changed through the key, the user will be alerted.

                            // Getting the indexes of every letter in the crib, within the plaintext array.
                            var crib_placements = find_crib_placement(plaintext, crib, crib_index);
                            console.log("Plaintext: " + plaintext);
                            console.log("Crib: " + crib);
                            console.log("Crib Index: " + crib_index);
                            console.log(`Crib Indexes: ${crib_placements}`);

                            // If the crib is changed through a key letter edit, then warn the user:
                            if (crib_placements.includes(i)) {
                                console.log("Test")
                                alert("Warning: The previous edit you made changed the crib. Please ensure that this is what you wanted to do.");
                            }

                            key[i] = letter;
                            update_plaintext(plaintext);
                        }
                    });
                }
            }

            // Given the plaintext array, this function will update it's contents to the page.
            function update_plaintext(plaintext) {
                plaintext = fill_plaintext(plaintext, ciphertext, key);
                //console.log("New plaintext: " + plaintext)

                for (let i = 0; i < plaintext.length; i++) {
                    document.getElementById(`${i}`).value = plaintext[i];
                }
            }

            // Given the key array, this function will update it's contents to the page.
            function update_key(key) {

                // Getting the latest version of the key from the backend
                key = fill_key(plaintext, ciphertext, key);
                //console.log("New key: " + key)


                // Displaying the new key values to the page
                for (let i = 0; i < key.length; i++) {
                    document.getElementById(`key${i}`).value = key[i];
                }
            }

            // Shifting the plaintext right
            $('#shift-right').click( () => {

                // Saving a copy of the original plaintext
                var original_plaintext = plaintext;

                plaintext = shift_array_right(plaintext);
                key = shift_array_right(key)

                // If the array was shifted right, update the crib index
                if (compare_array(plaintext, original_plaintext) == false) {
                    crib_index++;
                }

                // console.log(`Crib Index: ${crib_index}`);
                // var crib_placements = find_crib_placement(plaintext, crib, crib_index);            
                // console.log(`Crib Indexes: ${crib_placements}`);

                // The order in which these are called ensures that the plaintext will never be changed based on shifting.
                update_key(key);
                update_plaintext(plaintext);
            });

            // Shifting the plaintext left
            $('#shift-left').click( () => {

                // Saving a copy of the original plaintext
                var original_plaintext = plaintext;

                plaintext = shift_array_left(plaintext);
                key = shift_array_left(key);

                // If the array was shifted left, update the crib index
                if (compare_array(plaintext, original_plaintext) == false) {
                    crib_index--;
                }

                // console.log(`Crib Index: ${crib_index}`)
                // var crib_placements = find_crib_placement(plaintext, crib, crib_index);            
                // console.log(`Crib Indexes: ${crib_placements}`);

                update_key(key);
                update_plaintext(plaintext);
            });

            // Function that generates the initial table that will be shown on the web page.
            // This is only called once
            function write(ciphertext, plaintext, key) {
                var myTableDiv = document.getElementById("container")
                var table = document.createElement('TABLE')
                var tableBody = document.createElement('TBODY')

                table.appendChild(tableBody);

                // Ciphertext
                var tr = document.createElement('TR');
                tr.id = "ciphertext_row";
                tableBody.appendChild(tr);
                for (i = 0; i < ciphertext.length; i++) {
                    var th = document.createElement('TH')
                    th.id = `ciphertext${i}`;
                    th.appendChild(document.createTextNode(ciphertext[i]));
                    tr.appendChild(th);
                }

                // Plaintext
                var tr = document.createElement('TR');
                tr.id = "plaintext_row";
                tableBody.appendChild(tr);
                for (i = 0; i < ciphertext.length; i++) {
                    var td = document.createElement('TD')
                    var element = document.createElement('INPUT');
                    element.maxLength = 1;
                    element.value = plaintext[i];
                    element.id = `${i}`

                    td.appendChild(element);
                    tr.appendChild(td);
                }

                // Key (input)
                key = fill_key(plaintext, ciphertext, key);
                var tr = document.createElement('TR');
                tr.id = "key_row";
                tableBody.appendChild(tr);
                for (i = 0; i < ciphertext.length; i++) {
                    var td = document.createElement('TD')
                    var element = document.createElement('INPUT');
                    element.maxLength = 1;
                    element.value = key[i];
                    element.id = `key${i}`;
                    
                    td.appendChild(element);
                    tr.appendChild(td);
                }

                // Key (no input)
                // key = fill_key(plaintext, ciphertext, key);
                // var tr = document.createElement('TR');
                // tr.id = "key_row";
                // tableBody.appendChild(tr);
                // for (i = 0; i < ciphertext.length; i++) {
                //     var td = document.createElement('TD')
                //     td.id = `key${i}`;
                //     td.appendChild(document.createTextNode(key[i]));
                //     tr.appendChild(td);
                // }

                // Appending the new data to the table
                myTableDiv.appendChild(table)
            }
    
        </script>

    </body>

</html>